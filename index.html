<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>BAULA</title>
  <!-- Favicon / App Icons -->
  <link rel="icon" href="assets/ball.png" type="image/png" />
  <link rel="shortcut icon" href="assets/ball.png" type="image/png" />
  <link rel="apple-touch-icon" href="assets/ball.png" />
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      background-color: #1e1e1e;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      text-align: center;
      color: white;
      user-select: none;
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      touch-action: manipulation;
      -webkit-touch-callout: none;
      -webkit-tap-highlight-color: transparent;
      overflow: hidden;
      margin: 0;
      padding: 0;
      height: 100vh;
    }

    h1 {
      margin: 20px;
      font-size: 2.5rem;
    }

    canvas {
      margin-top: 100px;
      background: #333;
      border: 4px solid #ccc;
      border-radius: 15px;
      outline: none;
      touch-action: none;
      -webkit-touch-callout: none;
      -webkit-tap-highlight-color: transparent;
      max-width: 100%;
      max-height: 80vh;
      display: block;
      margin-left: auto;
      margin-right: auto;
    }
  </style>
</head>

<body>

  <canvas id="gameCanvas" width="1400" height="600" tabindex="0"></canvas>

  <script>
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");
    canvas.focus(); // Focus canvas for keyboard events

    // Player (Ball)
    const ball = {
      x: 100,
      y: 300,
      width: 50,
      height: 50,
      velocityY: 0,
      jumpForce: 12,
      gravity: 0.6,
      grounded: true,
      bounciness: 0.7,
      rotation: 0,
      rotationSpeed: 0.03,
      jumpsRemaining: 1, // Added for the "one jump" feature
      maxJumps: 1,       // Maximum number of extra jumps (1 for a double jump, 0 for single jump)
    };

    let obstacles = [];
    let frames = 0;
    let score = 0;
    let gameOver = false;
    let waitingForRestart = false;
    let highScore = localStorage.getItem('highScore') ? parseInt(localStorage.getItem('highScore')) : 0;
    let newHighScore = false;
    let nextObstacleFrame = 0;
    let gameState = "menu"; // 'menu', 'playing', 'settings', 'about', 'gameover', 'commands'
    let menuOptions = ["Play", "Settings", "About"];
    let selectedMenu = 0;
    let menuHover = -1;
    let menuBalls = Array.from({ length: 10 }, () => ({
      x: Math.random() * 1400,
      y: Math.random() * 600,
      r: 20 + Math.random() * 20,
      dx: -1 - Math.random() * 2,
      color: `rgba(${100 + Math.random() * 155},${200 + Math.random() * 55},${100 + Math.random() * 155},0.15)`
    }));

    const DEFAULT_MUSIC_VOLUME = 0.5;
    const DEFAULT_SFX_VOLUME = 0.8;
    let musicVolume = DEFAULT_MUSIC_VOLUME;
    let soundVolume = DEFAULT_SFX_VOLUME;
    let musicMuted = false;
    let soundMuted = false;

    // Improved settings options with grouping and tooltips
    const settingsOptions = [
      { group: 'Ball Physics', label: 'Jump Force', key: 'jumpForce', min: 5, max: 30, step: 1, type: 'number', initialValue: 12, defaultValue: 12, tooltip: 'How high the ball jumps.' },
      { group: 'Ball Physics', label: 'Gravity', key: 'gravity', min: 0.1, max: 2, step: 0.05, type: 'number', initialValue: 0.6, defaultValue: 0.6, tooltip: 'How fast the ball falls.' },
      { group: 'Ball Physics', label: 'Bounciness', key: 'bounciness', min: 0, max: 1, step: 0.05, type: 'number', initialValue: 0.7, defaultValue: 0.7, tooltip: 'How much the ball bounces on the ground.' },
      { group: 'Obstacles', label: 'Obstacle Speed', key: 'obstacleSpeed', min: 2, max: 15, step: 0.5, type: 'number', initialValue: 6, defaultValue: 6, tooltip: 'How fast obstacles move.' },
      { group: 'Audio', label: 'Music', key: 'musicMuted', type: 'toggle', initialValue: !musicMuted, defaultValue: true, tooltip: 'Toggle background music on or off.' },
      { group: 'Audio', label: 'Sound FX', key: 'soundMuted', type: 'toggle', initialValue: !soundMuted, defaultValue: true, tooltip: 'Toggle sound effects on or off.' },
      { group: 'General', label: 'Default', key: 'reset', type: 'button', tooltip: 'Restore all settings to their default values.' },
      { group: 'General', label: 'Commands', key: 'commands', type: 'button', tooltip: 'View all controls and rules.' },
      { group: 'General', label: 'Back', key: 'back', type: 'button', tooltip: 'Return to the main menu.' },
    ];
    const SPECIAL_SETTING_KEYS = ['reset', 'commands', 'back'];
    const SETTINGS_LAYOUT = {
      panelTop: 10,
      panelWidth: 800,
      basePanelHeight: 560,
      startY: 90,
      groupGap: 35,
      rowGap: 48,
      sliderWidth: 300,
      sliderHeight: 20,
      toggleWidth: 150,
      toggleHeight: 40,
      buttonWidth: 150,
      buttonHeight: 45,
      buttonSpacing: 40,
      footerOffset: 0
    };
    let selectedSetting = 0;
    let isDraggingSlider = false;
    let homeButtonHover = false; // Add this for hover effect
    let homeImg = new Image(); // Create image object for home icon
    homeImg.src = "assets/home.png";
  let obstacleSpeed = settingsOptions.find(opt => opt.key === 'obstacleSpeed').initialValue;

  function getSettingValue(opt) {
    switch (opt.key) {
      case 'obstacleSpeed':
        return obstacleSpeed;
      case 'musicMuted':
        return !musicMuted; // Inverted: true means ON, false means OFF
      case 'soundMuted':
        return !soundMuted; // Inverted: true means ON, false means OFF
      default:
        return ball[opt.key];
    }
  }

  function setSettingValue(opt, value) {
    switch (opt.key) {
      case 'obstacleSpeed':
        obstacleSpeed = value;
        break;
      case 'musicMuted':
        // Inverted logic: value=true means music ON, value=false means music OFF
        musicMuted = !Boolean(value);
        if (musicMuted) {
          bgMusic.pause();
        } else {
          bgMusic.volume = musicVolume;
          if (gameState === 'playing') {
            playBackgroundMusic();
          }
        }
        break;
      case 'soundMuted':
        // Inverted logic: value=true means sound ON, value=false means sound OFF
        soundMuted = !Boolean(value);
        break;
      default:
        ball[opt.key] = value;
        break;
    }
    opt.initialValue = value;
  }

  function toggleSetting(opt) {
    setSettingValue(opt, !getSettingValue(opt));
  }

  function syncAllSettings() {
    settingsOptions.forEach(opt => {
      opt.initialValue = getSettingValue(opt);
    });
  }

  function getSettingsLayoutInfo() {
    const positions = new Map();
    let y = SETTINGS_LAYOUT.startY;
    let lastGroup = '';
    for (let i = 0; i < settingsOptions.length; i++) {
      const opt = settingsOptions[i];
      if (SPECIAL_SETTING_KEYS.includes(opt.key)) {
        continue;
      }
      if (opt.group && opt.group !== lastGroup) {
        y += SETTINGS_LAYOUT.groupGap;
        lastGroup = opt.group;
      }
      positions.set(i, y);
      y += SETTINGS_LAYOUT.rowGap;
    }
    const specialIndices = settingsOptions
      .map((opt, idx) => SPECIAL_SETTING_KEYS.includes(opt.key) ? idx : -1)
      .filter(idx => idx !== -1);
    return { positions, lastY: y, specialIndices };
  }
    let autopilotEnabled = false; // Hidden autopilot mode

    let stars = [];
    const starImg = new Image();
    starImg.src = "assets/star.png";
    let nextStarFrame = 0;
    let powerUpActive = false;
    let powerUpTimer = 0;
    let powerUpTextTimer = 0;
    const POWER_UP_DURATION = 600; // frames (10 seconds at 60fps)
    const POWER_UP_TEXT_DURATION = 60; // frames for 'Power Up!' text
    const NORMAL_JUMP_FORCE = ball.jumpForce;
    const POWER_JUMP_FORCE = 20;
    
    // Star2 system (speed boost + grass immunity)
    let stars2 = [];
    const star2Img = new Image();
    star2Img.src = "assets/star2.png";
    let nextStar2Frame = 0;
    let speedBoostActive = false;
    let speedBoostTimer = 0;
    let speedBoostTextTimer = 0;
    const SPEED_BOOST_DURATION = 600; // frames (10 seconds at 60fps)
    const SPEED_BOOST_TEXT_DURATION = 60; // frames for 'Speed Boost!' text
    const SPEED_MULTIPLIER = 10; // 10x speed
    let grassImmunity = false;
    
    // Global power-up cooldown system
    let powerUpCooldown = false;
    let powerUpCooldownTimer = 0;
    const POWER_UP_COOLDOWN_DURATION = 300; // frames (5 seconds at 60fps)
    
    // Background music
    const bgMusic = new Audio();
    bgMusic.src = "assets/BG.wav";
    bgMusic.loop = true;
    bgMusic.volume = musicVolume;

    let audioCtx = null;
    let noiseBuffer = null;
    
    const GROUND_HEIGHT = 100;

    // Background music control functions
    function playBackgroundMusic(restart = false) {
      if (musicMuted) {
        return;
      }
      try {
        if (restart) {
          bgMusic.currentTime = 0;
        }
        bgMusic.volume = musicVolume;
        bgMusic.play().catch(error => {
          console.log("Audio play failed:", error);
          // Browser may require user interaction before playing audio
        });
      } catch (error) {
        console.log("Audio error:", error);
      }
    }
    
    function stopBackgroundMusic() {
      try {
        bgMusic.pause();
        bgMusic.currentTime = 0; // Reset to beginning
      } catch (error) {
        console.log("Audio stop error:", error);
      }
    }

    function ensureAudioContext() {
      const AudioContextCtor = window.AudioContext || window.webkitAudioContext;
      if (!AudioContextCtor) {
        return null;
      }
      if (!audioCtx) {
        audioCtx = new AudioContextCtor();
      }
      if (audioCtx.state === "suspended") {
        audioCtx.resume().catch(() => { /* ignore resume errors */ });
      }
      return audioCtx;
    }

    function canPlaySfx() {
      return !soundMuted && soundVolume > 0.001;
    }

    function getNoiseBuffer(ctx) {
      if (noiseBuffer) {
        return noiseBuffer;
      }
      const duration = 0.4;
      const buffer = ctx.createBuffer(1, ctx.sampleRate * duration, ctx.sampleRate);
      const data = buffer.getChannelData(0);
      for (let i = 0; i < data.length; i++) {
        data[i] = Math.random() * 2 - 1;
      }
      noiseBuffer = buffer;
      return noiseBuffer;
    }

    function playJumpSound(force) {
      if (!canPlaySfx()) {
        return;
      }
      const ctx = ensureAudioContext();
      if (!ctx) {
        return;
      }
      const now = ctx.currentTime;
      const osc = ctx.createOscillator();
      const gain = ctx.createGain();
      const baseline = NORMAL_JUMP_FORCE || 12;
      const intensity = Math.min(Math.max(force / baseline, 0.5), 2);
      const startFreq = 220 + intensity * 160;
      const endFreq = Math.max(120, startFreq - 140 * intensity);

      osc.type = "triangle";
      osc.frequency.setValueAtTime(startFreq, now);
      osc.frequency.exponentialRampToValueAtTime(endFreq, now + 0.3);

      const peakGain = soundVolume * 0.55 * Math.min(intensity, 1.4);
      gain.gain.setValueAtTime(peakGain, now);
      gain.gain.exponentialRampToValueAtTime(0.0001, now + 0.32);

      osc.connect(gain);
      gain.connect(ctx.destination);

      osc.start(now);
      osc.stop(now + 0.35);
      osc.onended = () => {
        osc.disconnect();
        gain.disconnect();
      };
    }

    function playLandingSound(surface, impactVelocity) {
      if (!canPlaySfx()) {
        return;
      }
      const ctx = ensureAudioContext();
      if (!ctx) {
        return;
      }
      const now = ctx.currentTime;
      const intensity = Math.min(Math.max(impactVelocity / 18, 0.2), 1.6);

      // Shared low-frequency thump
      const thumpOsc = ctx.createOscillator();
      thumpOsc.type = "sine";
      const thumpGain = ctx.createGain();
      const thumpStartFreq = surface === "grass" ? 120 : 90;
      const thumpEndFreq = surface === "grass" ? 70 : 60;
      thumpOsc.frequency.setValueAtTime(thumpStartFreq + intensity * 30, now);
      thumpOsc.frequency.exponentialRampToValueAtTime(thumpEndFreq, now + 0.35);
      thumpGain.gain.setValueAtTime(soundVolume * 0.6 * intensity, now);
      thumpGain.gain.exponentialRampToValueAtTime(0.0001, now + 0.4);
      thumpOsc.connect(thumpGain);
      thumpGain.connect(ctx.destination);
      thumpOsc.start(now);
      thumpOsc.stop(now + 0.4);
      thumpOsc.onended = () => {
        thumpOsc.disconnect();
        thumpGain.disconnect();
      };

      if (surface === "grass") {
        const noiseSource = ctx.createBufferSource();
        noiseSource.buffer = getNoiseBuffer(ctx);
        const filter = ctx.createBiquadFilter();
        filter.type = "bandpass";
        filter.frequency.setValueAtTime(1500, now);
        filter.Q.setValueAtTime(1, now);
        const noiseGain = ctx.createGain();
        noiseGain.gain.setValueAtTime(soundVolume * 0.4 * intensity, now);
        noiseGain.gain.exponentialRampToValueAtTime(0.0001, now + 0.3);
        noiseSource.connect(filter);
        filter.connect(noiseGain);
        noiseGain.connect(ctx.destination);
        noiseSource.start(now);
        noiseSource.stop(now + 0.32);
        noiseSource.onended = () => {
          noiseSource.disconnect();
          filter.disconnect();
          noiseGain.disconnect();
        };
      }
    }

    function playJumpBoostSound() {
      if (!canPlaySfx()) {
        return;
      }
      const ctx = ensureAudioContext();
      if (!ctx) {
        return;
      }
      const now = ctx.currentTime;
      
      // Rising arpeggio with sparkle effect
      const frequencies = [440, 554.37, 659.25, 880]; // A4, C#5, E5, A5
      frequencies.forEach((freq, index) => {
        const osc = ctx.createOscillator();
        const gain = ctx.createGain();
        
        osc.type = "sine";
        osc.frequency.setValueAtTime(freq, now);
        
        const startTime = now + index * 0.08;
        const duration = 0.3;
        
        gain.gain.setValueAtTime(0, startTime);
        gain.gain.linearRampToValueAtTime(soundVolume * 0.4, startTime + 0.02);
        gain.gain.exponentialRampToValueAtTime(0.0001, startTime + duration);
        
        osc.connect(gain);
        gain.connect(ctx.destination);
        
        osc.start(startTime);
        osc.stop(startTime + duration);
        osc.onended = () => {
          osc.disconnect();
          gain.disconnect();
        };
      });
      
      // Add shimmer/sparkle with high-frequency modulation
      const shimmerOsc = ctx.createOscillator();
      const shimmerGain = ctx.createGain();
      const shimmerLFO = ctx.createOscillator();
      const shimmerLFOGain = ctx.createGain();
      
      shimmerOsc.type = "triangle";
      shimmerOsc.frequency.setValueAtTime(1760, now); // A6
      
      shimmerLFO.type = "sine";
      shimmerLFO.frequency.setValueAtTime(8, now); // 8 Hz vibrato
      shimmerLFOGain.gain.setValueAtTime(100, now);
      
      shimmerLFO.connect(shimmerLFOGain);
      shimmerLFOGain.connect(shimmerOsc.frequency);
      
      shimmerGain.gain.setValueAtTime(soundVolume * 0.25, now);
      shimmerGain.gain.exponentialRampToValueAtTime(0.0001, now + 0.5);
      
      shimmerOsc.connect(shimmerGain);
      shimmerGain.connect(ctx.destination);
      
      shimmerLFO.start(now);
      shimmerOsc.start(now);
      shimmerLFO.stop(now + 0.5);
      shimmerOsc.stop(now + 0.5);
      shimmerOsc.onended = () => {
        shimmerOsc.disconnect();
        shimmerGain.disconnect();
        shimmerLFO.disconnect();
        shimmerLFOGain.disconnect();
      };
    }

    function playSpeedBoostSound() {
      if (!canPlaySfx()) {
        return;
      }
      const ctx = ensureAudioContext();
      if (!ctx) {
        return;
      }
      const now = ctx.currentTime;
      
      // Swoosh effect with descending pitch
      const swooshOsc = ctx.createOscillator();
      const swooshGain = ctx.createGain();
      const swooshFilter = ctx.createBiquadFilter();
      
      swooshOsc.type = "sawtooth";
      swooshFilter.type = "lowpass";
      swooshFilter.Q.setValueAtTime(5, now);
      
      // Rapid frequency sweep for "whoosh" effect
      swooshOsc.frequency.setValueAtTime(800, now);
      swooshOsc.frequency.exponentialRampToValueAtTime(200, now + 0.25);
      
      swooshFilter.frequency.setValueAtTime(2000, now);
      swooshFilter.frequency.exponentialRampToValueAtTime(400, now + 0.25);
      
      swooshGain.gain.setValueAtTime(soundVolume * 0.5, now);
      swooshGain.gain.exponentialRampToValueAtTime(0.0001, now + 0.3);
      
      swooshOsc.connect(swooshFilter);
      swooshFilter.connect(swooshGain);
      swooshGain.connect(ctx.destination);
      
      swooshOsc.start(now);
      swooshOsc.stop(now + 0.35);
      swooshOsc.onended = () => {
        swooshOsc.disconnect();
        swooshFilter.disconnect();
        swooshGain.disconnect();
      };
      
      // Add metallic "zoom" layer
      const zoomOsc = ctx.createOscillator();
      const zoomGain = ctx.createGain();
      const zoomFilter = ctx.createBiquadFilter();
      
      zoomOsc.type = "square";
      zoomFilter.type = "bandpass";
      zoomFilter.frequency.setValueAtTime(1200, now);
      zoomFilter.Q.setValueAtTime(10, now);
      
      zoomOsc.frequency.setValueAtTime(600, now);
      zoomOsc.frequency.exponentialRampToValueAtTime(150, now + 0.2);
      
      zoomGain.gain.setValueAtTime(soundVolume * 0.3, now);
      zoomGain.gain.exponentialRampToValueAtTime(0.0001, now + 0.25);
      
      zoomOsc.connect(zoomFilter);
      zoomFilter.connect(zoomGain);
      zoomGain.connect(ctx.destination);
      
      zoomOsc.start(now);
      zoomOsc.stop(now + 0.28);
      zoomOsc.onended = () => {
        zoomOsc.disconnect();
        zoomFilter.disconnect();
        zoomGain.disconnect();
      };
      
      // Jet engine-like noise burst
      const noiseSource = ctx.createBufferSource();
      noiseSource.buffer = getNoiseBuffer(ctx);
      const noiseFilter = ctx.createBiquadFilter();
      const noiseGain = ctx.createGain();
      
      noiseFilter.type = "highpass";
      noiseFilter.frequency.setValueAtTime(800, now);
      noiseFilter.frequency.exponentialRampToValueAtTime(2000, now + 0.15);
      
      noiseGain.gain.setValueAtTime(soundVolume * 0.35, now);
      noiseGain.gain.exponentialRampToValueAtTime(0.0001, now + 0.2);
      
      noiseSource.connect(noiseFilter);
      noiseFilter.connect(noiseGain);
      noiseGain.connect(ctx.destination);
      
      noiseSource.start(now);
      noiseSource.stop(now + 0.22);
      noiseSource.onended = () => {
        noiseSource.disconnect();
        noiseFilter.disconnect();
        noiseGain.disconnect();
      };
    }

    function playPowerUpEndSound() {
      if (!canPlaySfx()) {
        return;
      }
      const ctx = ensureAudioContext();
      if (!ctx) {
        return;
      }
      const now = ctx.currentTime;
      
      // Gentle descending chime
      const osc = ctx.createOscillator();
      const gain = ctx.createGain();
      
      osc.type = "sine";
      osc.frequency.setValueAtTime(880, now); // A5
      osc.frequency.exponentialRampToValueAtTime(440, now + 0.4); // A4
      
      gain.gain.setValueAtTime(soundVolume * 0.3, now);
      gain.gain.exponentialRampToValueAtTime(0.0001, now + 0.5);
      
      osc.connect(gain);
      gain.connect(ctx.destination);
      
      osc.start(now);
      osc.stop(now + 0.5);
      osc.onended = () => {
        osc.disconnect();
        gain.disconnect();
      };
    }

    // Function to resize canvas based on screen size and settings
    function resizeCanvas() {
      const isMobile = window.innerWidth <= 768 || window.innerHeight <= 600;
      
  if (isMobile) {
        // Use full screen width for mobile or when setting is enabled
        canvas.width = Math.max(window.innerWidth - 20, 800);
        canvas.height = Math.min(window.innerHeight - 40, 600);
      } else {
        // Default desktop size
        canvas.width = 1400;
        canvas.height = 600;
      }
      
      // Update canvas style to maintain aspect ratio
      const maxWidth = window.innerWidth - 20;
      const maxHeight = window.innerHeight - 40;
      
      if (canvas.width > maxWidth || canvas.height > maxHeight) {
        const scale = Math.min(maxWidth / canvas.width, maxHeight / canvas.height);
        canvas.style.width = (canvas.width * scale) + 'px';
        canvas.style.height = (canvas.height * scale) + 'px';
      } else {
        canvas.style.width = canvas.width + 'px';
        canvas.style.height = canvas.height + 'px';
      }
    }

    // Moon image
    const moonImg = new Image();
    moonImg.src = 'assets/moon.png';

    // Moon state
    let moonX = 1200;
    let moonY = 80;
    const moonSpeed = 0.04;

    // --- Add after other const declarations
    let damageFlashTimer = 0;

    // Cloud system
    const cloudImageFiles = [
      'assets/cloud1.png',
      'assets/cloud2.png',
      'assets/cloud3.png',
      'assets/cloud4.png'
    ];
    const cloudImages = cloudImageFiles.map(src => {
      const img = new Image();
      img.src = src;
      img.onerror = () => console.log('Failed to load cloud image:', src);
      return img;
    });

    // Cloud layers for parallax effect
    let cloudLayers = [
      { // Far clouds (slow, small, transparent)
        clouds: [],
        speed: 0.3,
        minSize: 80,
        maxSize: 120,
        opacity: 0.15,
        spawnRate: 200
      },
      { // Mid clouds (medium speed, medium size)
        clouds: [],
        speed: 0.6,
        minSize: 120,
        maxSize: 180,
        opacity: 0.25,
        spawnRate: 150
      },
      { // Near clouds (fast, large, more visible)
        clouds: [],
        speed: 1.0,
        minSize: 160,
        maxSize: 240,
        opacity: 0.35,
        spawnRate: 100
      }
    ];

    // Function to add initial clouds
    function addInitialClouds() {
      cloudLayers.forEach((layer, layerIndex) => {
        // Add 3-5 initial clouds for each layer
        const initialCloudCount = 3 + Math.floor(Math.random() * 3);
        for (let i = 0; i < initialCloudCount; i++) {
          const cloudSize = layer.minSize + Math.random() * (layer.maxSize - layer.minSize);
          const cloudY = 40 + Math.random() * (canvas.height - GROUND_HEIGHT - 200);
          const cloudX = Math.random() * canvas.width; // Spread across screen
          const cloudImageIndex = Math.floor(Math.random() * cloudImages.length);
          
          layer.clouds.push({
            x: cloudX,
            y: cloudY,
            size: cloudSize,
            imageIndex: cloudImageIndex,
            speed: layer.speed + (Math.random() - 0.5) * 0.2
          });
        }
      });
    }

    // --- Helper function to reset game state ---
    function resetGame() {
      ball.x = 100;
      ball.y = 300;
      ball.velocityY = 0;
      ball.rotation = 0;
      ball.rotationSpeed = 0.03;
      ball.grounded = true;
      ball.jumpsRemaining = ball.maxJumps; // Reset jumps
      obstacles = [];
      frames = 0;
      score = 0;
      gameOver = false;
      waitingForRestart = false;
      newHighScore = false; // Reset new high score flag
      nextObstacleFrame = 0;
      powerUpActive = false;
      ball.jumpForce = NORMAL_JUMP_FORCE;
      powerUpTimer = 0;
      powerUpTextTimer = 0;
      speedBoostActive = false;
      speedBoostTimer = 0;
      speedBoostTextTimer = 0;
      grassImmunity = false;
      powerUpCooldown = false;
      powerUpCooldownTimer = 0;
      damageFlashTimer = 0;

      // Randomize moon position
      moonX = canvas.width - Math.random() * 400;
      moonY = 40 + Math.random() * 60;

      // Reset cloud layers and add initial clouds
      cloudLayers.forEach(layer => {
        layer.clouds = [];
      });
      addInitialClouds(); // Add initial clouds immediately
      
      // Reset stars and stars2
      stars = [];
      stars2 = [];
      nextStarFrame = 0;
      nextStar2Frame = 0;

      // Start background music
      playBackgroundMusic(true);
    }

    canvas.addEventListener("click", function (e) {
      const rect = canvas.getBoundingClientRect();
      const mouseX = e.clientX - rect.left;
      const mouseY = e.clientY - rect.top;

      if (gameState === "menu") {
        for (let i = 0; i < menuOptions.length; i++) {
          const x = canvas.width / 2 - 100;
          const y = 220 + i * 70;
          if (
            mouseX > x && mouseX < x + 200 &&
            mouseY > y - 30 && mouseY < y + 30
          ) {
            selectedMenu = i;
            if (menuOptions[i] === "Play") {
              gameState = "playing";
              resetGame();
              playBackgroundMusic(true); // Start music when starting game
            } else if (menuOptions[i] === "Settings") {
              gameState = "settings";
              syncAllSettings();
            } else if (menuOptions[i] === "About") {
              gameState = "about";
            }
            return;
          }
        }
      } else if (gameState === "settings") {
        const panelWidth = SETTINGS_LAYOUT.panelWidth;
        const panelX = canvas.width / 2 - panelWidth / 2;
        const sliderX = panelX + 360;
        const sliderWidth = SETTINGS_LAYOUT.sliderWidth;
        const toggleWidth = SETTINGS_LAYOUT.toggleWidth;
        const toggleHeight = SETTINGS_LAYOUT.toggleHeight;
        const labelX = panelX + 50;
        const labelWidth = panelWidth - 100;
        const { positions, lastY, specialIndices } = getSettingsLayoutInfo();

        for (const [idx, rowCenterY] of positions.entries()) {
          const opt = settingsOptions[idx];
          const rowTop = rowCenterY - 30;
          const rowHeight = 50;

          if (opt.type === 'number') {
            const sliderY = rowCenterY - SETTINGS_LAYOUT.sliderHeight;
            if (
              mouseX > labelX && mouseX < labelX + labelWidth &&
              mouseY > rowTop && mouseY < rowTop + rowHeight
            ) {
              selectedSetting = idx;
              if (
                mouseX > sliderX && mouseX < sliderX + sliderWidth &&
                mouseY > sliderY && mouseY < sliderY + 18
              ) {
                const clickRatio = (mouseX - sliderX) / sliderWidth;
                let newValue = opt.min + clickRatio * (opt.max - opt.min);
                newValue = Math.round(newValue / opt.step) * opt.step;
                newValue = Math.max(opt.min, Math.min(opt.max, newValue));
                setSettingValue(opt, newValue);
                isDraggingSlider = true;
              }
              return;
            }
          } else if (opt.type === 'toggle') {
            const toggleX = sliderX;
            const toggleY = rowCenterY - toggleHeight;
            if (
              mouseX > toggleX && mouseX < toggleX + toggleWidth &&
              mouseY > toggleY && mouseY < toggleY + toggleHeight
            ) {
              selectedSetting = idx;
              toggleSetting(opt);
              return;
            }
            if (
              mouseX > labelX && mouseX < labelX + labelWidth &&
              mouseY > rowTop && mouseY < rowTop + rowHeight
            ) {
              selectedSetting = idx;
              toggleSetting(opt);
              return;
            }
          }
        }

        const buttonCount = specialIndices.length;
        if (buttonCount > 0) {
          const buttonRowY = lastY + 10;
          const buttonWidth = SETTINGS_LAYOUT.buttonWidth;
          const buttonHeight = SETTINGS_LAYOUT.buttonHeight;
          const buttonSpacing = SETTINGS_LAYOUT.buttonSpacing;
          const totalRowWidth = buttonWidth * buttonCount + buttonSpacing * (buttonCount - 1);
          const startX = canvas.width / 2 - totalRowWidth / 2;
          for (let j = 0; j < buttonCount; j++) {
            const idx = specialIndices[j];
            const opt = settingsOptions[idx];
            const buttonX = startX + j * (buttonWidth + buttonSpacing);
            const buttonY = buttonRowY;
            if (
              mouseX > buttonX && mouseX < buttonX + buttonWidth &&
              mouseY > buttonY && mouseY < buttonY + buttonHeight
            ) {
              selectedSetting = idx;
              if (opt.key === 'reset') {
                settingsOptions.forEach(opt2 => {
                  if (opt2.type === 'number' || opt2.type === 'toggle') {
                    setSettingValue(opt2, opt2.defaultValue);
                  }
                });
                syncAllSettings();
                return;
              }
              if (opt.key === 'commands') {
                gameState = 'commands';
                return;
              }
              if (opt.key === 'back') {
                gameState = 'menu';
                return;
              }
            }
          }
        }
      } else if (gameState === "commands" || gameState === "about") {
        gameState = "menu"; // Click anywhere to return to menu from commands/about
      }
      else if (gameOver && waitingForRestart) {
        const rect = canvas.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;
        // Check if Home button symbol is clicked in the top-right corner
        const homeButtonX = canvas.width - 70;
        const homeButtonY = 20;
        if (
          mouseX > homeButtonX && mouseX < homeButtonX + 50 &&
          mouseY > homeButtonY && mouseY < homeButtonY + 50
        ) {
          gameState = "menu";
          homeButtonHover = false; // Reset hover state
          stopBackgroundMusic(); // Stop music when going to menu
          return;
        }
        // If not clicked, restart game
        gameState = "playing";
        resetGame();
        playBackgroundMusic(true); // Start music when restarting
      }
    });

    canvas.addEventListener('mousedown', function (e) {
      if (gameState === 'settings') {
        const rect = canvas.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;
  const panelWidth = SETTINGS_LAYOUT.panelWidth;
  const panelX = canvas.width / 2 - panelWidth / 2;
  const sliderX = panelX + 360;
  const sliderWidth = SETTINGS_LAYOUT.sliderWidth;
        const { positions } = getSettingsLayoutInfo();
        for (const [idx, rowCenterY] of positions.entries()) {
          const opt = settingsOptions[idx];
          if (opt.type !== 'number') {
            continue;
          }
          const sliderY = rowCenterY - SETTINGS_LAYOUT.sliderHeight;
          if (mouseX > sliderX && mouseX < sliderX + sliderWidth &&
            mouseY > sliderY && mouseY < sliderY + SETTINGS_LAYOUT.sliderHeight) {
            selectedSetting = idx;
            isDraggingSlider = true;
            const clickRatio = (mouseX - sliderX) / sliderWidth;
            let newValue = opt.min + clickRatio * (opt.max - opt.min);
            newValue = Math.round(newValue / opt.step) * opt.step;
            newValue = Math.max(opt.min, Math.min(opt.max, newValue));
            setSettingValue(opt, newValue);
            break;
          }
        }
      }
    });

    canvas.addEventListener('mousemove', function (e) {
      const rect = canvas.getBoundingClientRect();
      const mouseX = e.clientX - rect.left;
      const mouseY = e.clientY - rect.top;

  if (gameState === 'settings' && isDraggingSlider) {
        const opt = settingsOptions[selectedSetting];
        if (opt && opt.type === 'number') {
          const panelWidth = SETTINGS_LAYOUT.panelWidth;
          const panelX = canvas.width / 2 - panelWidth / 2;
          const sliderX = panelX + 360;
          const sliderWidth = SETTINGS_LAYOUT.sliderWidth;
          let newValue = opt.min + ((mouseX - sliderX) / sliderWidth) * (opt.max - opt.min);
          newValue = Math.round(newValue / opt.step) * opt.step;
          newValue = Math.max(opt.min, Math.min(opt.max, newValue));
          setSettingValue(opt, newValue);
        }
      } else if (gameState === "menu") {
        menuHover = -1;
        for (let i = 0; i < menuOptions.length; i++) {
          const x = canvas.width / 2 - 100;
          const y = 220 + i * 70;
          if (
            mouseX > x && mouseX < x + 200 &&
            mouseY > y - 30 && mouseY < y + 30
          ) {
            menuHover = i;
            selectedMenu = i;
            break;
          }
        }
      } else if (gameState === "gameover") {
        const homeButtonX = canvas.width - 70;
        const homeButtonY = 20;
        if (
          mouseX > homeButtonX && mouseX < homeButtonX + 50 &&
          mouseY > homeButtonY && mouseY < homeButtonY + 50
        ) {
          homeButtonHover = true;
        } else {
          homeButtonHover = false;
        }
      }
    });

    canvas.addEventListener('mouseup', function () {
      isDraggingSlider = false;
    });

    canvas.addEventListener("mouseleave", function () {
      menuHover = -1;
      isDraggingSlider = false; // Stop dragging if mouse leaves canvas
    });

    // Touch event listeners for mobile
    canvas.addEventListener("touchstart", function (e) {
      e.preventDefault(); // Prevent default touch behavior
      
      const rect = canvas.getBoundingClientRect();
      const scaleX = canvas.width / rect.width;
      const scaleY = canvas.height / rect.height;
      const touch = e.touches[0];
      const touchX = (touch.clientX - rect.left) * scaleX;
      const touchY = (touch.clientY - rect.top) * scaleY;

      if (gameState === "playing") {
        // Touch to jump
        if (ball.grounded) {
          ball.velocityY = -ball.jumpForce;
          ball.grounded = false;
          ball.rotationSpeed = 0.4;
          ball.jumpsRemaining = ball.maxJumps;
          playJumpSound(ball.jumpForce);
        } else if (ball.jumpsRemaining > 0) {
          ball.velocityY = -ball.jumpForce;
          ball.rotationSpeed = 0.4;
          ball.jumpsRemaining--;
          playJumpSound(ball.jumpForce);
        }
      } else {
        // Simulate click for menus
        const clickEvent = new MouseEvent('click', {
          clientX: touch.clientX,
          clientY: touch.clientY,
          bubbles: true
        });
        canvas.dispatchEvent(clickEvent);
      }
    });

    canvas.addEventListener("touchmove", function (e) {
      e.preventDefault(); // Prevent scrolling
      
      if (gameState === 'settings' && isDraggingSlider) {
        const rect = canvas.getBoundingClientRect();
        const scaleX = canvas.width / rect.width;
        const touch = e.touches[0];
        const touchX = (touch.clientX - rect.left) * scaleX;
        
        const opt = settingsOptions[selectedSetting];
        if (opt && opt.type === 'number') {
          const panelWidth = SETTINGS_LAYOUT.panelWidth;
          const panelX = canvas.width / 2 - panelWidth / 2;
          const sliderX = panelX + 320;
          const sliderWidth = SETTINGS_LAYOUT.sliderWidth;
          let newValue = opt.min + ((touchX - sliderX) / sliderWidth) * (opt.max - opt.min);
          newValue = Math.round(newValue / opt.step) * opt.step;
          newValue = Math.max(opt.min, Math.min(opt.max, newValue));
          setSettingValue(opt, newValue);
        }
      }
    });

    canvas.addEventListener("touchend", function (e) {
      e.preventDefault();
      isDraggingSlider = false;
    });

    document.addEventListener("keydown", function (e) {
      // --- Hidden Autopilot Toggle ---
      if (e.ctrlKey && e.shiftKey && (e.code === 'KeyA' || e.key === 'A')) {
        autopilotEnabled = !autopilotEnabled;
        e.preventDefault();
        return;
      }

      if (gameState === "menu") {
        if (e.code === "ArrowUp") {
          selectedMenu = (selectedMenu + menuOptions.length - 1) % menuOptions.length;
          e.preventDefault();
        } else if (e.code === "ArrowDown") {
          selectedMenu = (selectedMenu + 1) % menuOptions.length;
          e.preventDefault();
        } else if (e.code === "Enter" || e.code === "Space") {
          e.preventDefault();
          if (menuOptions[selectedMenu] === "Play") {
            gameState = "playing";
            resetGame();
            playBackgroundMusic(true); // Start music when starting game
          } else if (menuOptions[selectedMenu] === "Settings") {
            gameState = "settings";
            syncAllSettings();
          } else if (menuOptions[selectedMenu] === "About") {
            gameState = "about";
          }
        }
        return;
      }

      if (gameState === "settings") {
        if (e.code === "ArrowUp") {
          selectedSetting = (selectedSetting + settingsOptions.length - 1) % settingsOptions.length;
          e.preventDefault();
        } else if (e.code === "ArrowDown") {
          selectedSetting = (selectedSetting + 1) % settingsOptions.length;
          e.preventDefault();
        } else if (
          (e.code === "ArrowLeft" || e.code === "ArrowRight") &&
          settingsOptions[selectedSetting].type === 'number'
        ) {
          const opt = settingsOptions[selectedSetting];
          let value = getSettingValue(opt);
          value += e.code === "ArrowLeft" ? -opt.step : opt.step;
          value = Math.max(opt.min, Math.min(opt.max, value));
          value = Math.round(value / opt.step) * opt.step;
          setSettingValue(opt, value);
          e.preventDefault();
        } else if (
          (e.code === "ArrowLeft" || e.code === "ArrowRight") &&
          settingsOptions[selectedSetting].type === 'toggle'
        ) {
          const opt = settingsOptions[selectedSetting];
          toggleSetting(opt);
          e.preventDefault();
        } else if (e.code === "ArrowLeft") {
          // If on a special button, move left among them
          const specialKeys = SPECIAL_SETTING_KEYS;
          const specialIndices = settingsOptions
            .map((opt, i) => specialKeys.includes(opt.key) ? i : -1)
            .filter(i => i !== -1);
          if (specialIndices.includes(selectedSetting)) {
            let idx = specialIndices.indexOf(selectedSetting);
            idx = (idx + specialIndices.length - 1) % specialIndices.length;
            selectedSetting = specialIndices[idx];
          } else {
            // Otherwise, do nothing or optionally move to last special button if at end
          }
          e.preventDefault();
        } else if (e.code === "ArrowRight") {
          // If on a special button, move right among them
          const specialKeys = SPECIAL_SETTING_KEYS;
          const specialIndices = settingsOptions
            .map((opt, i) => specialKeys.includes(opt.key) ? i : -1)
            .filter(i => i !== -1);
          if (specialIndices.includes(selectedSetting)) {
            let idx = specialIndices.indexOf(selectedSetting);
            idx = (idx + 1) % specialIndices.length;
            selectedSetting = specialIndices[idx];
          } else {
            // Otherwise, do nothing or optionally move to first special button if at end
          }
          e.preventDefault();
        } else if (e.code === "ArrowLeft" || e.code === "ArrowRight") {
          e.preventDefault();
        } else if (
          (e.code === "Enter" || e.code === "Space") &&
          settingsOptions[selectedSetting].type === 'toggle'
        ) {
          toggleSetting(settingsOptions[selectedSetting]);
          e.preventDefault();
        } else if ((e.code === "Enter" || e.code === "Space") && settingsOptions[selectedSetting].key === 'reset') {
          settingsOptions.forEach(opt2 => {
            if (opt2.type === 'number' || opt2.type === 'toggle') {
              setSettingValue(opt2, opt2.defaultValue);
            }
          });
          syncAllSettings();
          e.preventDefault();
        } else if ((e.code === "Enter" || e.code === "Space") && settingsOptions[selectedSetting].key === 'commands') {
          gameState = 'commands';
          e.preventDefault();
        } else if ((e.code === "Enter" || e.code === "Space") && settingsOptions[selectedSetting].key === 'back') {
          gameState = 'menu';
          e.preventDefault();
        } else if (e.code === "Escape") { // Only ESC to return to menu from settings
          gameState = "menu";
          e.preventDefault();
        } else if (e.code === "Backspace") { // Backspace to return to menu from settings
          gameState = "menu";
          e.preventDefault();
        }
        return;
      }

      if (gameState === "about" || gameState === "commands") { // Return from about or commands screen
        if (e.code === "Escape" || e.code === "Enter" || e.code === "Space") {
          gameState = "menu";
          e.preventDefault();
        }
        return;
      }

      if (gameState === "gameover") {
        if (e.key === "h" || e.key === "H") {
          gameState = "menu";
          stopBackgroundMusic(); // Stop music when going to menu
          return;
        }
        gameState = "playing";
        resetGame();
        playBackgroundMusic(true); // Start music when restarting
        e.preventDefault();
        return;
      }

      // Game playing controls
      if ((e.code === "Space" || e.code === "ArrowUp")) {
        if (ball.grounded) {
          ball.velocityY = -ball.jumpForce;
          ball.grounded = false;
          ball.rotationSpeed = 0.4;
          ball.jumpsRemaining = ball.maxJumps; // Reset jumps when grounded jump occurs
          playJumpSound(ball.jumpForce);
          e.preventDefault();
        } else if (ball.jumpsRemaining > 0) { // For the "one jump" in mid-air/bounce
          ball.velocityY = -ball.jumpForce;
          ball.rotationSpeed = 0.4;
          ball.jumpsRemaining--; // Consume one extra jump
          playJumpSound(ball.jumpForce);
          e.preventDefault();
        }
      }

      if ((e.code === "ArrowDown") && ball.grounded) {
        ball.velocityY = ball.jumpForce;
        ball.grounded = false;
        ball.rotationSpeed = -0.4;
        e.preventDefault();
      }

      if (e.code === "ArrowLeft") {
        ball.x -= getBallMoveSpeed();
        e.preventDefault();
      }

      if (e.code === "ArrowRight") {
        ball.x += getBallMoveSpeed();
        e.preventDefault();
      }
    });

    class Obstacle {
      constructor() {
        this.width = 40 + Math.random() * 40; // width between 40 and 80
        this.height = 30 + Math.random() * 40; // height between 30 and 70
        this.x = canvas.width;
        this.y = canvas.height - this.height - GROUND_HEIGHT;
        // Gradually increase speed as score increases
        const baseSpeed = obstacleSpeed;
        const maxSpeed = settingsOptions.find(opt => opt.key === 'obstacleSpeed').max;
        const speedIncreaseRate = 0.07; // Tune this for difficulty ramp
        this.speed = Math.min(baseSpeed + score * speedIncreaseRate, maxSpeed);
      }

      draw() {
        ctx.drawImage(grassImg, this.x, this.y, this.width, this.height);
      }

      update() {
        this.x -= this.speed;
        this.draw();
      }
    }

    const ballImg = new Image();
    ballImg.src = "assets/ball.png";

    const grassImg = new Image();
    grassImg.src = "assets/grass.png";

    let imagesLoadedCount = 0;
    const totalImages = 2;

    function imageLoaded() {
      imagesLoadedCount++;
      if (imagesLoadedCount === totalImages) {
        update();
      }
    }

    ballImg.onload = imageLoaded;
    grassImg.onload = imageLoaded;

    if (ballImg.complete && grassImg.complete) {
      imageLoaded();
      imageLoaded();
    }

    // Initialize canvas size and add window resize listener
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);
    window.addEventListener('orientationchange', function() {
      setTimeout(resizeCanvas, 100); // Delay to allow orientation change to complete
    });

    function drawBall() {
      ctx.save();
      ctx.translate(ball.x + ball.width / 2, ball.y + ball.height / 2);
      ctx.rotate(ball.rotation);
      ctx.drawImage(ballImg, -ball.width / 2, -ball.height / 2, ball.width, ball.height);
      ctx.restore();
    }

    function drawMenu() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      for (let ball of menuBalls) {
        ctx.beginPath();
        ctx.arc(ball.x, ball.y, ball.r, 0, Math.PI * 2);
        ctx.fillStyle = ball.color;
        ctx.fill();
        ball.x += ball.dx;
        if (ball.x + ball.r < 0) {
          ball.x = canvas.width + ball.r;
          ball.y = Math.random() * canvas.height;
          ball.r = 20 + Math.random() * 20;
          ball.dx = -1 - Math.random() * 2;
          ball.color = `rgba(${100 + Math.random() * 155},${200 + Math.random() * 55},${100 + Math.random() * 155},0.15)`;
        }
      }

      let pulse = Math.floor(128 + 127 * Math.sin(Date.now() / 500));
      ctx.font = "bold 70px Courier New, monospace";
      ctx.textAlign = "center";
      ctx.fillStyle = `rgb(${pulse},${255 - pulse / 2},${100 + pulse / 3})`;
      ctx.shadowColor = `rgba(${pulse},${255 - pulse / 2},${100 + pulse / 3},0.7)`;
      ctx.shadowBlur = 30;
      ctx.fillText("BAULA", canvas.width / 2, 160);
      ctx.shadowBlur = 0;

      ctx.font = "bold 28px Courier New, monospace";
      for (let i = 0; i < menuOptions.length; i++) {
        let isSelected = (i === selectedMenu) || (i === menuHover);
        ctx.save();

        const buttonWidth = 200;
        const buttonHeight = 60;
        const buttonX = canvas.width / 2 - buttonWidth / 2;
        const buttonY = 220 + i * 70 - buttonHeight / 2;
        const borderRadius = 30;

        ctx.beginPath();
        ctx.roundRect(buttonX, buttonY, buttonWidth, buttonHeight, borderRadius);
        ctx.fillStyle = isSelected ? "#00FF99" : "#fff";
        ctx.shadowColor = isSelected ? "#00FF99" : "#333";
        ctx.shadowBlur = isSelected ? 20 : 8;
        ctx.fill();
        ctx.shadowBlur = 0;
        ctx.lineWidth = 3;
        ctx.strokeStyle = isSelected ? "#222" : "#333";
        ctx.stroke();

        ctx.fillStyle = isSelected ? "#222" : "#333";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(menuOptions[i], canvas.width / 2, 220 + i * 70);
        ctx.restore();
      }
      ctx.font = "20px Courier New, monospace";
      ctx.fillStyle = "#fff";
      ctx.textAlign = "center";
      ctx.fillText("Use ↑/↓ and Enter, or click, to select", canvas.width / 2, 500);
      ctx.fillText("Tip: You can use keyboard or mouse!", canvas.width / 2, 540);
    }

    function drawSettings() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      // --- Card/Panel Background ---

    const panelWidth = SETTINGS_LAYOUT.panelWidth;
    const panelHeight = SETTINGS_LAYOUT.basePanelHeight;
      const panelX = canvas.width / 2 - panelWidth / 2;
    const panelY = SETTINGS_LAYOUT.panelTop;
      ctx.save();
      ctx.globalAlpha = 0.96;
      ctx.beginPath();
      ctx.roundRect(panelX, panelY, panelWidth, panelHeight, 40);
      ctx.fillStyle = "#333";
      ctx.shadowColor = "rgba(0,0,0,0.5)";
      ctx.shadowBlur = 36;
      ctx.fill();
      ctx.shadowBlur = 0;
      ctx.globalAlpha = 1.0;
      ctx.restore();
      // --- Title ---
      ctx.font = "bold 36px Courier New, monospace";
      ctx.fillStyle = "#00FF99";
      ctx.textAlign = "center";
      ctx.shadowColor = "#00FF99";
      ctx.shadowBlur = 20;
      ctx.fillText("Settings", canvas.width / 2, panelY + 40);
      ctx.shadowBlur = 0;

      // --- Settings List ---
      ctx.font = "bold 26px Courier New, monospace";
      ctx.textAlign = "left";
      let yStart = SETTINGS_LAYOUT.startY;
      let lastGroup = '';
      let y = yStart;
      // Collect indices for the three special buttons
      const specialKeys = SPECIAL_SETTING_KEYS;
      const specialButtonIndices = settingsOptions
        .map((opt, i) => specialKeys.includes(opt.key) ? i : -1)
        .filter(i => i !== -1);
      // Render all settings except the three special buttons
      for (let i = 0; i < settingsOptions.length; i++) {
        const opt = settingsOptions[i];
        if (SPECIAL_SETTING_KEYS.includes(opt.key)) continue; // Skip special buttons here
        const value = getSettingValue(opt);
        const textY = y;
        // --- Group Header ---
        if (opt.group && opt.group !== lastGroup) {
          ctx.font = "bold 22px Courier New, monospace";
          ctx.fillStyle = "#FFD700";
          ctx.textAlign = "left";
          ctx.fillText(opt.group, panelX + 50, y);
          // Underline
          ctx.strokeStyle = "#FFD700";
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(panelX + 50, y + 6);
          ctx.lineTo(panelX + 100, y + 6);
          ctx.stroke();
          y += SETTINGS_LAYOUT.groupGap;
          lastGroup = opt.group;
          ctx.font = "bold 26px Courier New, monospace";
        }
        // --- Setting Label ---
        ctx.fillStyle = i === selectedSetting ? "#00FF99" : "#fff";
        ctx.textAlign = "left";
        ctx.font = "bold 26px Courier New, monospace";
        ctx.fillText(opt.label + (opt.type === 'number' ? ':' : ''), panelX + 50, y);

        if (opt.type === 'number') {
          // --- Modern Slider ---
          const sliderX = panelX + 360;
          const sliderY = y - SETTINGS_LAYOUT.sliderHeight;
          const sliderWidth = SETTINGS_LAYOUT.sliderWidth;
          const sliderHeight = SETTINGS_LAYOUT.sliderHeight;
          const sliderKnobRadius = 16;

          // Slider bar gradient
          let grad = ctx.createLinearGradient(sliderX, sliderY, sliderX + sliderWidth, sliderY);
          grad.addColorStop(0, "#00FF99");
          grad.addColorStop(1, "#00C3FF");
          ctx.save();
          ctx.beginPath();
          ctx.roundRect(sliderX, sliderY, sliderWidth, sliderHeight, 9);
          ctx.fillStyle = grad;
          ctx.shadowColor = i === selectedSetting ? "#00FF99" : "#222";
          ctx.shadowBlur = i === selectedSetting ? 16 : 4;
          ctx.fill();
          ctx.shadowBlur = 0;
          // Slider rounded border (matches bar)
          ctx.strokeStyle = i === selectedSetting ? "#00FF99" : "#444";
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.roundRect(sliderX, sliderY, sliderWidth, sliderHeight, 9);
          ctx.stroke();
          ctx.restore();

          // Calculate knob position
          const valueRatio = (value - opt.min) / (opt.max - opt.min);
          const knobX = sliderX + valueRatio * sliderWidth;

          // --- Glowing Knob ---
          ctx.save();
          ctx.beginPath();
          ctx.arc(knobX, sliderY + sliderHeight / 2, sliderKnobRadius, 0, Math.PI * 2);
          ctx.fillStyle = i === selectedSetting ? "#00FF99" : "#fff";
          ctx.shadowColor = i === selectedSetting ? "#00FF99" : "#00C3FF";
          ctx.shadowBlur = i === selectedSetting ? 30 : 10;
          ctx.fill();
          ctx.shadowBlur = 0;
          ctx.lineWidth = 3;
          ctx.strokeStyle = i === selectedSetting ? "#222" : "#777";
          ctx.stroke();
          ctx.restore();

          // --- Value Text ---
          ctx.fillStyle = i === selectedSetting ? "#00FF99" : "#fff";
          ctx.textAlign = "right";
          ctx.font = "bold 24px Courier New, monospace";
          ctx.fillText(value.toFixed(2).replace(/\.0+$/, ''), sliderX + sliderWidth + 80, y + 2);
          ctx.font = "bold 26px Courier New, monospace";
        } else if (opt.type === 'toggle') {
          const toggleX = panelX + 360;
          const toggleY = y - SETTINGS_LAYOUT.toggleHeight;
          const toggleWidth = SETTINGS_LAYOUT.toggleWidth;
          const toggleHeight = SETTINGS_LAYOUT.toggleHeight;
          const knobPadding = 6;
          const knobDiameter = toggleHeight - knobPadding * 2;
          const isOn = Boolean(value);

          ctx.save();
          ctx.beginPath();
          ctx.roundRect(toggleX, toggleY, toggleWidth, toggleHeight, 18);
          const baseFill = isOn ? "#00FF99" : "#555";
          const selectedFill = isOn ? "#4effb9" : "#777";
          ctx.fillStyle = i === selectedSetting ? selectedFill : baseFill;
          if (i === selectedSetting) {
            ctx.shadowColor = isOn ? "#00FF99" : "#999";
            ctx.shadowBlur = 18;
          }
          ctx.fill();
          ctx.shadowBlur = 0;
          ctx.lineWidth = 2;
          ctx.strokeStyle = i === selectedSetting ? "#222" : "#333";
          ctx.stroke();

          const knobX = isOn
            ? toggleX + toggleWidth - knobPadding - knobDiameter
            : toggleX + knobPadding;
          const knobCenterY = toggleY + toggleHeight / 2;
          ctx.beginPath();
          ctx.arc(knobX + knobDiameter / 2, knobCenterY, knobDiameter / 2, 0, Math.PI * 2);
          ctx.fillStyle = "#fff";
          ctx.fill();
          ctx.lineWidth = 2;
          ctx.strokeStyle = i === selectedSetting ? "#222" : "#777";
          ctx.stroke();

          ctx.font = "bold 16px Courier New, monospace";
          ctx.textAlign = "center";
          ctx.fillStyle = isOn ? "#0f2e26" : "#ddd";
          ctx.fillText(isOn ? "ON" : "OFF", toggleX + toggleWidth / 2, knobCenterY + 5);
          ctx.restore();
        }
        y += SETTINGS_LAYOUT.rowGap;
      }

      // --- Special Buttons Row (Reset, Commands, Back) ---
      const buttonRowY = y - 10;
      const buttonWidth = SETTINGS_LAYOUT.buttonWidth;
      const buttonHeight = SETTINGS_LAYOUT.buttonHeight;
      const buttonSpacing = SETTINGS_LAYOUT.buttonSpacing;
  const totalRowWidth = buttonWidth * specialButtonIndices.length + buttonSpacing * Math.max(0, specialButtonIndices.length - 1);
      const startX = canvas.width / 2 - totalRowWidth / 2;
      for (let j = 0; j < specialButtonIndices.length; j++) {
        const i = specialButtonIndices[j];
        const opt = settingsOptions[i];
        const buttonX = startX + j * (buttonWidth + buttonSpacing);
        const buttonY = buttonRowY;
        const borderRadius = 20;
        ctx.save();
        ctx.beginPath();
        ctx.roundRect(buttonX, buttonY, buttonWidth, buttonHeight, borderRadius);
        // Color by type
        if (opt.key === 'reset') {
          ctx.fillStyle = i === selectedSetting ? "#FF6666" : "#fff";
          ctx.shadowColor = i === selectedSetting ? "#FF6666" : "transparent";
        } else if (opt.key === 'commands') {
          ctx.fillStyle = i === selectedSetting ? "#00FF99" : "#fff";
          ctx.shadowColor = i === selectedSetting ? "#00FF99" : "transparent";
        } else if (opt.key === 'back') {
          ctx.fillStyle = i === selectedSetting ? "#FFD700" : "#fff";
          ctx.shadowColor = i === selectedSetting ? "#FFD700" : "transparent";
        } else {
          ctx.fillStyle = i === selectedSetting ? "#00C3FF" : "#fff";
          ctx.shadowColor = i === selectedSetting ? "#00C3FF" : "transparent";
        }
        ctx.shadowBlur = i === selectedSetting ? 18 : 0;
        ctx.fill();
        ctx.shadowBlur = 0;
        ctx.lineWidth = 2;
        ctx.strokeStyle = i === selectedSetting ? "#222" : "#333";
        ctx.stroke();
        // Button label
        ctx.fillStyle = i === selectedSetting ? "#222" : "#333";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.font = "bold 20px Courier New, monospace";
        ctx.fillText(opt.label, buttonX + buttonWidth / 2, buttonY + buttonHeight / 2);
        ctx.restore();
      }
      y = buttonRowY + buttonHeight + 10;

      // --- Footer Help Text ---
      ctx.font = "16px Courier New, monospace";
      ctx.fillStyle = "#aaa";
      ctx.textAlign = "center";
      ctx.fillText("Use ↑/↓ to select, ←/→ or drag to adjust, Enter/Space/Click to activate", canvas.width / 2, panelY + panelHeight - 15);
    }

    function drawCommands() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.font = "bold 50px Courier New, monospace";
      ctx.fillStyle = "#FFD700";
      ctx.textAlign = "center";
      ctx.fillText("Rules & Commands", canvas.width / 2, 120);
      ctx.font = "24px Courier New, monospace";
      ctx.fillStyle = "#fff";
      const rules = [
        'Space / Up Arrow / Touch Screen: Jump (can perform one extra jump in air/bounce)',
        'Down Arrow: Fast fall (when grounded)',
        'Left/Right Arrow: Move horizontally',
        'Click or Enter/Space: Select menu option / Interact with settings',
        'ESC: Back to main menu (from settings, about, commands)',
        'Touch & Drag: Adjust settings sliders on mobile',
        'Score increases for each obstacle passed',
        'Game Over on collision',
        'High Score is saved in your browser',
      ];
      let y = 180;
      for (let i = 0; i < rules.length; i++) {
        ctx.fillText(rules[i], canvas.width / 2, y + i * 36);
      }
      ctx.font = "bold 24px Courier New, monospace";
      ctx.fillStyle = "#00FF99";
      ctx.fillText("Press ESC, Enter, or Space to return", canvas.width / 2, y + rules.length * 40);
    }

    function drawAbout() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.font = "bold 60px Courier New, monospace";
      ctx.fillStyle = "#00FF99";
      ctx.textAlign = "center";
      ctx.fillText("About", canvas.width / 2, 150);
      ctx.font = "30px Courier New, monospace";
      ctx.fillStyle = "#fff";
      ctx.fillText("BAULA", canvas.width / 2, 250);
      ctx.fillText("Created by Bipin Yadav", canvas.width / 2, 300);
      ctx.fillText("YEAH! I MADE THIS ", canvas.width / 2, 350);
      ctx.font = "15px Courier New, monospace";
      ctx.fillText("Press any key or click to return", canvas.width / 2, 500);
    }

    function update() {
      if (gameState === "menu") {
        drawMenu();
      } else if (gameState === "settings") {
        drawSettings();
      } else if (gameState === "commands") {
        drawCommands();
      } else if (gameState === "about") {
        drawAbout();
      } else if (gameState === "playing") {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        // Background
        ctx.fillStyle = '#333'; // Dark gray instead of pure black
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Draw moon
        moonX -= moonSpeed;
        if (moonX < -120) moonX = canvas.width + 120;
        ctx.save();
        ctx.globalAlpha = 0.85;
        ctx.drawImage(moonImg, moonX, moonY, 120, 120);
        ctx.restore();

        // Ground
        ctx.fillStyle = "#555";
        ctx.fillRect(0, canvas.height - GROUND_HEIGHT, canvas.width, GROUND_HEIGHT);

        // --- Autopilot Logic ---
        const wasGrounded = ball.grounded;
        let groundImpactVelocity = 0;
        if (autopilotEnabled) {
          // Find the next obstacle in front of the ball
          let nextObs = null;
          for (let obs of obstacles) {
            if (obs.x + obs.width > ball.x && obs.x > ball.x) {
              nextObs = obs;
              break;
            }
          }
          if (nextObs && ball.grounded) {
            // Estimate time to reach obstacle
            const dx = (nextObs.x - (ball.x + ball.width));
            const speed = nextObs.speed;
            // Ball jump arc: t = 2 * jumpForce / gravity (time in air)
            const jumpTime = 2 * ball.jumpForce / ball.gravity;
            // How far the obstacle will move in that time
            const obsTravel = speed * jumpTime;
            // Buffer increases with speed
            const buffer = 60 + speed * 10;
            // Minimum distance to avoid jumping too late
            const minJumpDist = 60;
            // Jump if obstacle is within the jump arc distance + buffer, but not too close
            if (dx > minJumpDist && dx < obsTravel + nextObs.width / 2 + buffer) {
              ball.velocityY = -ball.jumpForce;
              ball.grounded = false;
              ball.rotationSpeed = 0.4;
              ball.jumpsRemaining = ball.maxJumps;
              playJumpSound(ball.jumpForce);
            }
          }
        }

        ball.velocityY += ball.gravity;
        ball.y += ball.velocityY;

        // Collision with ground
        if (ball.y > canvas.height - ball.height - GROUND_HEIGHT) {
          ball.y = canvas.height - ball.height - GROUND_HEIGHT;
          const impactVelocity = Math.abs(ball.velocityY);
          groundImpactVelocity = impactVelocity;
          if (impactVelocity > 2) {
            ball.velocityY = -ball.velocityY * ball.bounciness;
          } else {
            ball.velocityY = 0;
          }
          ball.grounded = true;
          ball.jumpsRemaining = ball.maxJumps; // Reset jumps when ball lands firmly
          ball.rotationSpeed = ball.rotationSpeed > 0 ? 0.03 : -0.03;
        } else {
          ball.grounded = false;
        }

        if (!wasGrounded && ball.grounded && groundImpactVelocity > 0.5) {
          playLandingSound('ground', groundImpactVelocity);
        }

        if (Math.abs(ball.rotationSpeed) > 0.03) {
          ball.rotationSpeed *= 0.95;
          if (Math.abs(ball.rotationSpeed) < 0.03) {
            ball.rotationSpeed = ball.rotationSpeed > 0 ? 0.03 : -0.03;
          }
        }
        ball.rotation += ball.rotationSpeed;

        drawBall();

        if (frames >= nextObstacleFrame) {
          obstacles.push(new Obstacle());
          nextObstacleFrame = frames + Math.floor(60 + Math.random() * 90);
        }

        for (let i = 0; i < obstacles.length; i++) {
          obstacles[i].update();

          // Check collision only if grass immunity is not active
          if (!grassImmunity &&
            ball.x < obstacles[i].x + obstacles[i].width &&
            ball.x + ball.width > obstacles[i].x &&
            ball.y < obstacles[i].y + obstacles[i].height &&
            ball.y + ball.height > obstacles[i].y
          ) {
            const impactSpeed = Math.abs(ball.velocityY) + obstacles[i].speed;
            playLandingSound('grass', impactSpeed);
            damageFlashTimer = 30;
            gameOver = true;
            waitingForRestart = true;
            gameState = "gameover";
            stopBackgroundMusic(); // Stop music when game ends
            break;
          }

          if (obstacles[i].x + obstacles[i].width < 0) {
            obstacles.splice(i, 1);
            score++;
            i--;
          }
        }

        // --- Star Spawning (only if score >= 5 and no power-ups active/cooldown) ---
        if (score >= 5 && frames >= nextStarFrame && !powerUpActive && !speedBoostActive && !powerUpCooldown) {
          const starSize = 80;
          const starY = canvas.height - GROUND_HEIGHT - starSize;
          const starX = canvas.width + starSize;
          let overlapsObstacle = false;
          for (let obs of obstacles) {
            if (
              starX < obs.x + obs.width &&
              starX + starSize > obs.x
            ) {
              overlapsObstacle = true;
              break;
            }
          }
          if (!overlapsObstacle) {
            stars.push({
              x: starX,
              y: starY,
              size: starSize,
              speed: getDynamicObstacleSpeed() + (Math.random() - 0.5) * 1.5 // add some random speed
            });
          }
          // Balanced spawn rate: 5-10 seconds between spawns
          nextStarFrame = frames + Math.floor(360 + Math.random() * 300);
        }

        // --- Star2 Spawning (speed boost, only if score >= 20 and no power-ups active/cooldown) ---
        if (score >= 20 && frames >= nextStar2Frame && !powerUpActive && !speedBoostActive && !powerUpCooldown) {
          const star2Size = 90;
          const star2Y = canvas.height - GROUND_HEIGHT - star2Size;
          const star2X = canvas.width + star2Size;
          let overlapsObstacle = false;
          for (let obs of obstacles) {
            if (
              star2X < obs.x + obs.width &&
              star2X + star2Size > obs.x
            ) {
              overlapsObstacle = true;
              break;
            }
          }
          if (!overlapsObstacle) {
            stars2.push({
              x: star2X,
              y: star2Y,
              size: star2Size,
              speed: getDynamicObstacleSpeed() + (Math.random() - 0.5) * 1.5
            });
          }
          // Balanced spawn rate: 10-20 seconds between spawns (rarer than jump boost)
          nextStar2Frame = frames + Math.floor(600 + Math.random() * 600);
        }

        // --- Update and Draw Stars ---
        for (let i = 0; i < stars.length; i++) {
          const star = stars[i];
          // Always match current dynamic obstacleSpeed
          const dynSpeed = star.speed; // use each star's own speed
          star.x -= dynSpeed;
          star.speed = dynSpeed;
          // Draw yellow glow matching the star's size
          ctx.save();
          ctx.shadowColor = '#FFD700'; // yellow glow
          ctx.shadowBlur = 40;
          ctx.drawImage(starImg, star.x, star.y, star.size, star.size);
          ctx.shadowBlur = 0;
          ctx.restore();
          // Collision with ball
          if (
            ball.x < star.x + star.size &&
            ball.x + ball.width > star.x &&
            ball.y < star.y + star.size &&
            ball.y + ball.height > star.y
          ) {
            // Only activate if no other power-up is active or on cooldown
            if (!powerUpActive && !speedBoostActive && !powerUpCooldown) {
              powerUpActive = true;
              powerUpTimer = POWER_UP_DURATION;
              powerUpTextTimer = POWER_UP_TEXT_DURATION;
              ball.jumpForce = POWER_JUMP_FORCE;
              playJumpBoostSound(); // Play jump boost sound effect
            }
            stars.splice(i, 1);
            i--;
            continue;
          }
          // Remove if offscreen
          if (star.x + star.size < 0) {
            stars.splice(i, 1);
            i--;
          }
        }

        // --- Update and Draw Stars2 (Speed Boost) ---
        for (let i = 0; i < stars2.length; i++) {
          const star2 = stars2[i];
          const dynSpeed = star2.speed;
          star2.x -= dynSpeed;
          star2.speed = dynSpeed;
          // Draw blue/cyan glow for star2
          ctx.save();
          ctx.shadowColor = '#00CCFF'; // blue/cyan glow
          ctx.shadowBlur = 50;
          ctx.drawImage(star2Img, star2.x, star2.y, star2.size, star2.size);
          ctx.shadowBlur = 0;
          ctx.restore();
          // Collision with ball
          if (
            ball.x < star2.x + star2.size &&
            ball.x + ball.width > star2.x &&
            ball.y < star2.y + star2.size &&
            ball.y + ball.height > star2.y
          ) {
            // Only activate if no other power-up is active or on cooldown
            if (!powerUpActive && !speedBoostActive && !powerUpCooldown) {
              speedBoostActive = true;
              speedBoostTimer = SPEED_BOOST_DURATION;
              speedBoostTextTimer = SPEED_BOOST_TEXT_DURATION;
              grassImmunity = true;
              playSpeedBoostSound(); // Play speed boost sound effect
            }
            stars2.splice(i, 1);
            i--;
            continue;
          }
          // Remove if offscreen
          if (star2.x + star2.size < 0) {
            stars2.splice(i, 1);
            i--;
          }
        }
        // --- Power-up logic ---
        if (powerUpActive) {
          // Visual effect: glow around ball (same size as ball)
          ctx.save();
          ctx.globalAlpha = 0.5;
          ctx.beginPath();
          ctx.arc(ball.x + ball.width / 2, ball.y + ball.height / 2, ball.width / 2, 0, Math.PI * 2);
          ctx.fillStyle = '#FFD700';
          ctx.shadowColor = '#FFD700';
          ctx.shadowBlur = 30;
          ctx.fill();
          ctx.restore();
          powerUpTimer--;
          if (powerUpTimer <= 0) {
            powerUpActive = false;
            ball.jumpForce = NORMAL_JUMP_FORCE;
            playPowerUpEndSound(); // Play power-up ending sound
            // Start cooldown period
            powerUpCooldown = true;
            powerUpCooldownTimer = POWER_UP_COOLDOWN_DURATION;
          }
        }
        
        // --- Speed Boost logic ---
        if (speedBoostActive) {
          // Visual effect: blue/cyan glow around ball (same size as ball, like jump power-up)
          ctx.save();
          ctx.globalAlpha = 0.5;
          ctx.beginPath();
          ctx.arc(ball.x + ball.width / 2, ball.y + ball.height / 2, ball.width / 2, 0, Math.PI * 2);
          ctx.fillStyle = '#00CCFF';
          ctx.shadowColor = '#00CCFF';
          ctx.shadowBlur = 30;
          ctx.fill();
          ctx.restore();
          speedBoostTimer--;
          if (speedBoostTimer <= 0) {
            speedBoostActive = false;
            grassImmunity = false;
            playPowerUpEndSound(); // Play power-up ending sound
            // Start cooldown period
            powerUpCooldown = true;
            powerUpCooldownTimer = POWER_UP_COOLDOWN_DURATION;
          }
        }
        
        // --- Power-up cooldown logic ---
        if (powerUpCooldown) {
          powerUpCooldownTimer--;
          if (powerUpCooldownTimer <= 0) {
            powerUpCooldown = false;
          }
        }
        // --- Power Up! text ---
        if (powerUpTextTimer > 0) {
          ctx.save();
          ctx.font = "bold 30px Courier New, monospace";
          ctx.fillStyle = "#FFD700";
          ctx.textAlign = "center";
          ctx.shadowColor = "#FFD700";
          ctx.shadowBlur = 20;
          ctx.fillText("Jump Boost!", ball.x + ball.width / 2, ball.y - 20);
          ctx.restore();
          powerUpTextTimer--;
        }
        
        // --- Speed Boost! text ---
        if (speedBoostTextTimer > 0) {
          ctx.save();
          ctx.font = "bold 30px Courier New, monospace";
          ctx.fillStyle = "#00CCFF";
          ctx.textAlign = "center";
          ctx.shadowColor = "#00CCFF";
          ctx.shadowBlur = 20;
          ctx.fillText("Speed Boost!", ball.x + ball.width / 2, ball.y - 60);
          ctx.restore();
          speedBoostTextTimer--;
        }

        // --- Power-up Timer Display ---
        if (powerUpActive) {
          const timeLeft = (powerUpTimer / 60).toFixed(1);
          ctx.save();
          ctx.font = "bold 18px Courier New, monospace";
          ctx.fillStyle = "#FFD700";
          ctx.textAlign = "left";
          ctx.shadowColor = "#FFD700";
          ctx.shadowBlur = 10;
          ctx.fillText("⭐ Jump Boost: " + timeLeft + "s", 30, canvas.height - 30);
          ctx.restore();
        }
        
        if (speedBoostActive) {
          const timeLeft = (speedBoostTimer / 60).toFixed(1);
          ctx.save();
          ctx.font = "bold 18px Courier New, monospace";
          ctx.fillStyle = "#00CCFF";
          ctx.textAlign = "left";
          ctx.shadowColor = "#00CCFF";
          ctx.shadowBlur = 10;
          ctx.fillText("⚡ Speed Boost: " + timeLeft + "s", 30, canvas.height - 10);
          ctx.restore();
        }
        
        // --- Cooldown Indicator ---
        if (powerUpCooldown && !powerUpActive && !speedBoostActive) {
          const cooldownLeft = (powerUpCooldownTimer / 60).toFixed(1);
          ctx.save();
          ctx.font = "bold 16px Courier New, monospace";
          ctx.fillStyle = "#888";
          ctx.textAlign = "left";
          ctx.fillText("Power-up Cooldown: " + cooldownLeft + "s", 30, canvas.height - 30);
          ctx.restore();
        }

        ctx.fillStyle = "white";
        ctx.font = "bold 40px Courier New,Comic Sans MS, cursive, sans-serif";
        ctx.textAlign = "left";
        ctx.fillText("BAULA", 30, 65);

        ctx.font = "20px Courier New, monospace";
        ctx.fillText("High Score: " + highScore, 30, 90);
        ctx.fillText("Score: " + score, 30, 115);

        // --- Autopilot Indicator ---
        if (autopilotEnabled) {
          ctx.save();
          ctx.font = "bold 22px Courier New, monospace";
          ctx.fillStyle = "#00FF99";
          ctx.globalAlpha = 0.7;
          ctx.textAlign = "right";
          ctx.fillText("Autopilot ON", canvas.width - 30, 40);
          ctx.globalAlpha = 1.0;
          ctx.restore();
        }

        // --- Damage Flash Effect ---
        if (damageFlashTimer > 0) {
          ctx.save();
          ctx.globalAlpha = 0.3;
          ctx.beginPath();
          ctx.arc(ball.x + ball.width / 2, ball.y + ball.height / 2, ball.width * 0.8, 0, Math.PI * 2);
          ctx.fillStyle = '#FF2222';
          ctx.shadowColor = '#FF2222';
          ctx.shadowBlur = 20;
          ctx.fill();
          ctx.restore();
          damageFlashTimer--;
        }

        // --- Dynamic Cloud System ---
        cloudLayers.forEach((layer, layerIndex) => {
          // Spawn new clouds
          if (frames % layer.spawnRate === 0 && Math.random() < 0.3) {
            const cloudSize = layer.minSize + Math.random() * (layer.maxSize - layer.minSize);
            const cloudY = 40 + Math.random() * (canvas.height - GROUND_HEIGHT - 200);
            const cloudImageIndex = Math.floor(Math.random() * cloudImages.length);

            layer.clouds.push({
              x: canvas.width + cloudSize,
              y: cloudY,
              size: cloudSize,
              imageIndex: cloudImageIndex,
              speed: layer.speed + (Math.random() - 0.5) * 0.2
            });
          }

          // Update and draw clouds
          for (let i = layer.clouds.length - 1; i >= 0; i--) {
            const cloud = layer.clouds[i];
            cloud.x -= cloud.speed;

            // Draw cloud with atmospheric effect
            ctx.save();
            ctx.globalAlpha = layer.opacity + (Math.random() * 0.1);
            ctx.shadowColor = 'rgba(255, 255, 255, 0.1)';
            ctx.shadowBlur = 15;

            // Check if image is loaded before drawing
            if (cloudImages[cloud.imageIndex] && cloudImages[cloud.imageIndex].complete) {
              ctx.drawImage(
                cloudImages[cloud.imageIndex],
                cloud.x,
                cloud.y,
                cloud.size,
                cloud.size * 0.6
              );
            }
            ctx.restore();

            // Remove offscreen clouds
            if (cloud.x + cloud.size < -50) {
              layer.clouds.splice(i, 1);
            }
          }
        });

        frames++;
      } else if (gameState === "gameover") {
        powerUpActive = false;
        ball.jumpForce = NORMAL_JUMP_FORCE;
        speedBoostActive = false;
        grassImmunity = false;
        powerUpCooldown = false;
        if (score > highScore) {
          highScore = score;
          localStorage.setItem('highScore', highScore);
          newHighScore = true;
        }

        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.font = "bold 60px Courier New, monospace";
        ctx.fillStyle = "white";
        ctx.textAlign = "center";
        ctx.fillText("Game Over!", canvas.width / 2, 255);

        if (newHighScore) {
          ctx.font = "bold 30px Courier New, monospace";
          ctx.fillStyle = "#FFD700";
          ctx.fillText("New High Score!", canvas.width / 2, 200);
        }

        ctx.font = "20px Courier New, monospace";
        ctx.fillStyle = "white";
        ctx.fillText(`Your Score: ${score}`, canvas.width / 2, 300);
        ctx.fillText(`High Score: ${highScore}`, canvas.width / 2, 340);
        ctx.fillText("Press any key to Restart", canvas.width / 2, 380);

        // Draw Home button icon in top-right corner, with more distance
        const homeButtonX = canvas.width - 90; // Further from right edge
        const homeButtonY = 40;            // Further from top edge
        const homeButtonSize = 30;

        // Add hover effect (slight scaling)
        const scale = homeButtonHover ? 1.1 : 1.0;
        const scaledSize = homeButtonSize * scale;
        const scaledX = homeButtonX - (scaledSize - homeButtonSize) / 2;
        const scaledY = homeButtonY - (scaledSize - homeButtonSize) / 2;

        ctx.globalAlpha = homeButtonHover ? 1.0 : 0.8; // Change opacity on hover
        ctx.drawImage(homeImg, scaledX, scaledY, scaledSize, scaledSize);
        ctx.globalAlpha = 1.0; // Reset global alpha
      } else if (gameState === "menu") {
        powerUpActive = false;
        ball.jumpForce = NORMAL_JUMP_FORCE;
        speedBoostActive = false;
        grassImmunity = false;
        powerUpCooldown = false;
        drawMenu();
      }

      requestAnimationFrame(update);
    }

    // Ball movement speedup factor
    function getBallMoveSpeed() {
      const baseSpeed = 10 + Math.min(score * 0.15, 20); // base 10, up to +20 at high score
      return speedBoostActive ? baseSpeed * SPEED_MULTIPLIER : baseSpeed;
    }

    // Obstacle/star speedup factor
    function getDynamicObstacleSpeed() {
      // Use the base obstacleSpeed from settings, but add a factor for score
      const base = obstacleSpeed;
      return base + Math.min(score * 0.07, 10); // up to +10 speed
    }
  </script>
</body>

</html>